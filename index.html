<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nanobubble Cleaning Digital Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Custom Styles for an Immersive Digital Lab Feel */
        :root {
            --primary-color: #1a1a2e; /* Dark Blue Background */
            --accent-color: #00bcd4; /* Cyan/Aqua for Highlights */
            --success-color: #4CAF50; /* Green for Success */
            --warning-color: #FFC107; /* Yellow for Metrics */
            --text-color: #e4e4e7; /* Light text */
            --subtle-text: #a1a1aa; /* Subtle text */
            --contaminant-color: #5d4037; /* Dark Brown/Rust */
            --nanobubble-color: rgba(128, 216, 255, 0.8); /* Light Blue Bubble */
            --glass-color: rgba(150, 200, 255, 0.15); /* Light blue tint for glass effect */
            --glass-border: rgba(150, 200, 255, 0.5); 
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px; /* Reduced body padding for better fit */
        }

        .container {
            max-width: 950px; /* Slightly constrained width for wider screens */
            width: 95%;
            /* CRUCIAL: Max height to prevent vertical overflow */
            max-height: calc(100vh - 20px); 
            overflow-y: auto; /* Scroll only if absolutely necessary, but should prevent it */
            
            background-color: #24243e; /* Slightly lighter inner panel */
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 20px; /* Reduced container padding */
        }

        .card {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 20px;
            background-color: #2d2d4d;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        canvas {
            background-color: #1a1a2e;
            border-radius: 0.5rem;
            /* Ensures canvas width is fluid but maintains fixed drawing dimensions */
            width: 100%; 
            height: 400px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.7);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: var(--primary-color);
            padding: 12px 24px;
            border-radius: 0.75rem;
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 188, 212, 0.4);
        }

        .progress-bar-container {
            height: 12px;
            background-color: #3f3f5a;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--success-color);
            transition: width 0.5s ease-out;
        }

        .metric-gauge {
            width: 100%;
            height: 8px;
            background-color: #3f3f5a;
            border-radius: 4px;
            overflow: hidden;
        }

        .metric-fill {
            height: 100%;
            width: 0%;
            background-color: var(--warning-color);
            transition: width 0.5s ease-out;
        }
    </style>
</head>
<body class="selection:bg-cyan-500 selection:text-white">

    <div class="container">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center mb-3 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-teal-500">
            Nanobubble Cleaning Digital Lab Simulation
        </h1>
        <p class="text-center text-sm mb-4 text-subtle-text">Project: Electrolyte-Enhanced Nanobubble Cavitation for Surface Decontamination</p>

        <!-- Main Content Area -->
        <div class="card p-4 sm:p-8">
            <canvas id="experimentCanvas" width="800" height="400"></canvas>
            
            <!-- Step 1: Setup Screen -->
            <div id="setupDiv" class="text-center py-4">
                <h2 class="text-2xl font-semibold text-text-color mb-3">SETUP: Optimize Nanobubble Cleaning</h2>
                <p class="mb-5 text-subtle-text">Our hypothesis is that a **mild electrolyte (0.01M NaCl)** provides the optimal nanobubble stability, leading to maximum contaminant removal.</p>
                
                <!-- Concentration Selector: Uses responsive stacking -->
                <div class="flex flex-col sm:flex-row justify-center items-center gap-6 mb-6 text-left">
                    <div class="w-full sm:w-1/3 p-4 bg-gray-700/30 rounded-lg shadow-inner">
                        <label for="concentration" class="block text-sm font-medium text-accent-color mb-2">Select Electrolyte Concentration:</label>
                        <select id="concentration" class="w-full p-2 rounded-md bg-gray-700 text-text-color border border-gray-600 focus:ring-cyan-500 focus:border-cyan-500">
                            <option value="0.0">Pure Water (Control: 0.0M NaCl)</option>
                            <option value="0.005">Low Salt (0.005M NaCl)</option>
                            <option value="0.01" selected>Optimized Salt (0.01M NaCl)</option>
                            <option value="0.02">High Salt (0.02M NaCl)</option>
                        </select>
                    </div>
                </div>

                <button id="startButton" class="btn-primary" onclick="startExperiment()">
                    Start Nanobubble Experiment
                </button>
            </div>

            <!-- Step 2: Running Screen -->
            <div id="runningDiv" class="hidden text-center py-1">
                <h2 class="text-xl font-semibold text-accent-color mb-2">EXPERIMENT RUNNING... (12 Seconds)</h2>
                <div class="progress-bar-container mb-2">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
                <p id="phaseStatus" class="text-lg font-mono text-success-color mb-1"></p>

                <!-- Live Metrics: Responsive Stacking/Side-by-Side -->
                <div class="flex flex-wrap justify-center sm:justify-around items-start mt-3 mb-1 gap-y-4">
                    <div class="w-full sm:w-5/12 text-left p-3 rounded-lg bg-gray-700/30">
                        <span class="text-sm font-bold block text-subtle-text">Nanobubble Stability (CFD)</span>
                        <div class="metric-gauge">
                            <div id="stabilityGauge" class="metric-fill"></div>
                        </div>
                        <span id="stabilityValue" class="text-xs text-warning-color mt-1 block">0%</span>
                    </div>
                    <div class="w-full sm:w-5/12 text-left p-3 rounded-lg bg-gray-700/30">
                        <span class="text-sm font-bold block text-subtle-text">Micro-Jet Velocity (MD)</span>
                        <div class="metric-gauge">
                            <div id="velocityGauge" class="metric-fill"></div>
                        </div>
                        <span id="velocityValue" class="text-xs text-warning-color mt-1 block">0 m/s</span>
                    </div>
                </div>

            </div>

            <!-- Step 3: Results Screen -->
            <div id="resultsDiv" class="hidden text-center py-4">
                <h2 class="text-2xl font-bold text-success-color mb-3">FINAL RESULTS: Contaminant Removal Efficiency</h2>
                <p class="mb-5 text-subtle-text">Comparing the optimized solution against controls reveals the maximum cleaning power.</p>
                <button class="btn-primary" onclick="restartExperiment()">
                    Restart Experiment
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- Canvas and DOM Setup ---
        const canvas = document.getElementById('experimentCanvas');
        const ctx = canvas.getContext('2d');
        
        const setupDiv = document.getElementById('setupDiv');
        const runningDiv = document.getElementById('runningDiv');
        const resultsDiv = document.getElementById('resultsDiv');
        const phaseStatus = document.getElementById('phaseStatus');
        const progressBar = document.getElementById('progressBar');
        const concentrationSelect = document.getElementById('concentration');

        const stabilityGauge = document.getElementById('stabilityGauge');
        const stabilityValue = document.getElementById('stabilityValue');
        const velocityGauge = document.getElementById('velocityGauge');
        const velocityValue = document.getElementById('velocityValue');

        // --- Color Constants (JS equivalent of CSS variables for Canvas) ---
        const ACCENT_COLOR = '#00bcd4';
        const PRIMARY_COLOR = '#1a1a2e';
        const CONTAMINANT_COLOR = '#5d4037';
        const NANOBUBBLE_COLOR = 'rgba(128, 216, 255, 0.8)';
        const WARNING_COLOR = '#FFC107';
        const TEXT_COLOR = '#e4e4e7';
        // Updated Beaker Colors for better glass effect
        const BEAKER_COLOR = 'rgba(150, 200, 255, 0.15)'; 
        const BEAKER_STROKE = 'rgba(150, 200, 255, 0.5)';


        // --- Nanobubble Simulation Data (Fixed for the demonstration) ---
        const experimentPhases = [
            '1 of 3: Phase 1: Running CFD for Nanobubble Stability (Lifespan Model)...',
            '2 of 3: Phase 2: Molecular Dynamics of Cavitation Event (Micro-Jet Velocity)...',
            '3 of 3: Phase 3: Calculating Contaminant Removal Efficiency (Final Data)...'
        ];

        // Cleaning Efficiency Data (The award-winning data)
        const resultsData = {
            '0.0': { efficiency: 35, color: '#e57373' }, // Pure Water (low)
            '0.005': { efficiency: 68, color: '#ffee58' }, // Low Salt (better)
            '0.01': { efficiency: 92, color: '#66bb6a' },  // Optimized Salt (best)
            '0.02': { efficiency: 45, color: '#ff8a65' }   // High Salt (worse due to surface tension)
        };

        let bubbles = [];
        let contaminantHeight = 50;
        let animationFrameId = null;
        let simulationRunning = false;
        
        // Beaker Dimensions for clipping and drawing (Fixed size for consistent visualization)
        const beaker = {
            width: 300,
            height: 350,
            radius: 50, // Radius for the rounded bottom
            x: 0,
            y: 0,
            wallThickness: 10 // Thicker walls for better visibility
        };

        // --- Initialization and Utility Functions ---

        // Function to draw the Beaker shape and return a path for clipping
        function drawBeaker(x, y, isOutline = true) {
            ctx.lineWidth = isOutline ? 4 : 1; // Thicker outline
            ctx.strokeStyle = isOutline ? BEAKER_STROKE : ACCENT_COLOR;
            ctx.fillStyle = BEAKER_COLOR;

            const halfWidth = beaker.width / 2;
            const top = y;
            const bottomStraight = y + beaker.height - beaker.radius;
            const centerBottomY = y + beaker.height - beaker.radius;

            ctx.beginPath();
            
            // Top rim, start top left
            ctx.moveTo(x - halfWidth, top);
            ctx.lineTo(x + halfWidth, top);

            // Right side (straight down)
            ctx.lineTo(x + halfWidth, bottomStraight);

            // Rounded bottom (Arc)
            // Use a specific arc size to make it look like lab glassware
            ctx.arc(x, centerBottomY, halfWidth, 0, Math.PI, false);

            // Left side (straight up)
            ctx.lineTo(x - halfWidth, top);

            if (!isOutline) {
                ctx.fill();
            }
            ctx.stroke();
            ctx.closePath();
            
            // Return the path for clipping usage later
            return new Path2D(ctx.currentPath);
        }
        
        function drawSetupScreen() {
            ctx.fillStyle = PRIMARY_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const midX = canvas.width / 2;
            const midY = canvas.height / 2; 
            const topY = 30;
            beaker.x = midX;
            beaker.y = topY;

            // --- Draw Beaker Glass Effect ---
            // Draw the inner container area (the liquid area)
            const innerHalfWidth = beaker.width / 2 - 2;
            const innerX = midX;
            const innerY = topY + 2;
            
            // Draw the full beaker outline first (looks better this way)
            drawBeaker(midX, topY, true);

            // Fill with initial water (clipped to the inner area)
            ctx.save();
            
            // Create the path for clipping the liquid content
            ctx.beginPath();
            ctx.moveTo(innerX - innerHalfWidth, innerY);
            ctx.lineTo(innerX + innerHalfWidth, innerY);
            ctx.lineTo(innerX + innerHalfWidth, innerY + beaker.height - beaker.radius);
            ctx.arc(innerX, innerY + beaker.height - beaker.radius, innerHalfWidth, 0, Math.PI, false);
            ctx.lineTo(innerX - innerHalfWidth, innerY);
            ctx.closePath();
            ctx.clip(); // Apply clipping to the inner liquid area

            const waterGradient = ctx.createLinearGradient(0, topY + beaker.height, 0, topY);
            waterGradient.addColorStop(0, 'rgba(0, 188, 212, 0.4)');
            waterGradient.addColorStop(1, 'rgba(0, 188, 212, 0.1)');
            ctx.fillStyle = waterGradient;
            ctx.fillRect(innerX - innerHalfWidth, innerY, beaker.width, beaker.height);
            
            // Draw Contaminant Layer at the bottom (clipped)
            ctx.fillStyle = CONTAMINANT_COLOR;
            ctx.fillRect(innerX - innerHalfWidth, innerY + beaker.height - contaminantHeight, beaker.width, contaminantHeight);
            
            ctx.restore(); // Restore clipping
            
            // Draw Aeration Nozzle/System outside
            ctx.fillStyle = '#9e9e9e';
            ctx.fillRect(midX - 30, topY + beaker.height + 10, 60, 10);
            
            // Text labels (outside the beaker)
            ctx.fillStyle = TEXT_COLOR;
            ctx.font = '16px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('Aerated Water + Electrolyte', midX, topY - 10);
            ctx.fillText('Contaminant Target', midX, topY + beaker.height - 20);
            ctx.fillText('Click Start to Model Cleaning Process', midX, midY);
        }

        function createBubble(size = 3) {
            return {
                x: beaker.x - (beaker.width / 2) + Math.random() * beaker.width,
                y: beaker.y + beaker.height - beaker.radius + Math.random() * beaker.radius, 
                radius: size + Math.random() * 2,
                // REDUCED SPEED: Range 0.5 to 1.5 (much slower)
                speed: 0.5 + Math.random() * 1.0, 
                opacity: 0.5 + Math.random() * 0.5,
                bursting: false,
                burstTimer: 0
            };
        }

        function updateBubbles() {
            const cleaningSurfaceY = beaker.y + beaker.height - contaminantHeight;
            const innerHalfWidth = beaker.width / 2 - 2;
            const innerX = beaker.x;
            const innerY = beaker.y + 2;
            
            // Cleaning rate is tuned for the 12s duration
            const cleaningRate = 0.075; 

            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.y -= b.speed;
                b.opacity = Math.min(1, b.opacity + 0.01);

                // Check for collision with contaminant layer
                if (b.y <= cleaningSurfaceY && b.y > cleaningSurfaceY - 5 && !b.bursting) {
                    b.bursting = true;
                    b.burstTimer = 10; // Start burst animation
                    
                    // Simulate removal - scaled for 12s duration
                    contaminantHeight = Math.max(10, contaminantHeight - cleaningRate); 
                }

                // Check if bubble has left the beaker at the top
                const bubbleEscaped = b.y < innerY;

                if (b.bursting) {
                    b.burstTimer--;
                    if (b.burstTimer <= 0) {
                        bubbles.splice(i, 1); // Remove burst bubble
                    }
                } else if (bubbleEscaped) {
                    bubbles.splice(i, 1); // Remove escaped bubble
                }
            }
        }

        function drawBubbles() {
            for (const b of bubbles) {
                if (b.bursting) {
                    // Draw white flash for cavitation
                    ctx.fillStyle = `rgba(255, 255, 255, ${b.burstTimer / 10})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius * 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw stable bubble
                    ctx.fillStyle = NANOBUBBLE_COLOR;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawRunningScreen() {
            // Draw background
            ctx.fillStyle = PRIMARY_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const midX = canvas.width / 2;
            const topY = 30;
            beaker.x = midX;
            beaker.y = topY;

            // Draw Beaker Outline
            drawBeaker(midX, topY, true);

            // --- Start Clipping to Inner Liquid Area ---
            ctx.save();
            const innerHalfWidth = beaker.width / 2 - 2;
            const innerX = midX;
            const innerY = topY + 2;

            ctx.beginPath();
            ctx.moveTo(innerX - innerHalfWidth, innerY);
            ctx.lineTo(innerX + innerHalfWidth, innerY);
            ctx.lineTo(innerX + innerHalfWidth, innerY + beaker.height - beaker.radius);
            ctx.arc(innerX, innerY + beaker.height - beaker.radius, innerHalfWidth, 0, Math.PI, false);
            ctx.lineTo(innerX - innerHalfWidth, innerY);
            ctx.closePath();
            ctx.clip(); // Apply clipping

            // Fill with water
            const waterGradient = ctx.createLinearGradient(0, topY + beaker.height, 0, topY);
            waterGradient.addColorStop(0, 'rgba(0, 188, 212, 0.4)');
            waterGradient.addColorStop(1, 'rgba(0, 188, 212, 0.1)');
            ctx.fillStyle = waterGradient;
            ctx.fillRect(innerX - innerHalfWidth, innerY, beaker.width, beaker.height);


            // Draw Contaminant Layer at the bottom
            ctx.fillStyle = CONTAMINANT_COLOR;
            ctx.fillRect(innerX - innerHalfWidth, innerY + beaker.height - contaminantHeight, beaker.width, contaminantHeight);
            
            // Draw Bubbles (must be drawn before restoring to remain inside beaker)
            updateBubbles();
            drawBubbles();
            
            // End Clipping
            ctx.restore(); 
            
            // Draw Aeration Nozzle/System outside
            ctx.fillStyle = '#9e9e9e';
            ctx.fillRect(midX - 30, topY + beaker.height + 10, 60, 10);


            // Add new bubbles
            if (Math.random() < 1.0) { // High frequency for active bubbling
                bubbles.push(createBubble());
            }
        }

        function drawMetrics(stabilityPct, velocityMs) {
            const margin = 20;
            const cardWidth = 300;
            const cardHeight = 100;

            // Draw the metric box background
            ctx.fillStyle = 'rgba(45, 45, 77, 0.8)'; // Dark card color
            ctx.strokeStyle = ACCENT_COLOR;
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width - cardWidth - margin, margin, cardWidth, cardHeight);
            ctx.fillRect(canvas.width - cardWidth - margin, margin, cardWidth, cardHeight);

            ctx.fillStyle = TEXT_COLOR;
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('Live Computational Metrics', canvas.width - cardWidth, margin + 20);

            // Stability Gauge
            ctx.font = '12px Inter';
            ctx.fillText('Stability (CFD):', canvas.width - cardWidth, margin + 45);
            ctx.fillStyle = '#3f3f5a'; // Base bar color
            ctx.fillRect(canvas.width - cardWidth + 90, margin + 35, 180, 8);
            ctx.fillStyle = WARNING_COLOR;
            ctx.fillRect(canvas.width - cardWidth + 90, margin + 35, 180 * (stabilityPct / 100), 8);
            ctx.fillText(`${stabilityPct}%`, canvas.width - cardWidth + 200, margin + 45);


            // Velocity Gauge
            ctx.fillText('Velocity (MD):', canvas.width - cardWidth, margin + 75);
            ctx.fillStyle = '#3f3f5a'; // Base bar color
            ctx.fillRect(canvas.width - cardWidth + 90, margin + 65, 180, 8);
            
            const maxVelocity = 120; // Max velocity in m/s
            const currentVelocityPct = velocityMs / maxVelocity;
            ctx.fillStyle = WARNING_COLOR;
            ctx.fillRect(canvas.width - cardWidth + 90, margin + 65, 180 * currentVelocityPct, 8);
            ctx.fillText(`${velocityMs.toFixed(0)} m/s`, canvas.width - cardWidth + 200, margin + 75);
        }

        function drawResultsScreen() {
            ctx.fillStyle = PRIMARY_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const data = Object.values(resultsData);
            const labels = Object.keys(resultsData).map(c => c + 'M NaCl');
            const barWidth = 100;
            const spacing = 50;
            const startX = (canvas.width - (data.length * barWidth + (data.length - 1) * spacing)) / 2;
            const baseY = canvas.height - 40;
            const maxVal = 100;

            // Draw X-Axis Line
            ctx.strokeStyle = TEXT_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX - 20, baseY);
            ctx.lineTo(startX + data.length * barWidth + (data.length - 1) * spacing + 20, baseY);
            ctx.stroke();

            data.forEach((item, index) => {
                const x = startX + index * (barWidth + spacing);
                const height = (item.efficiency / maxVal) * (canvas.height - 100);

                // Draw Bar
                ctx.fillStyle = item.color;
                ctx.fillRect(x, baseY - height, barWidth, height);
                
                // Draw Bar Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(x + 5, baseY - height + 5, barWidth, height);
                ctx.fillStyle = item.color;
                ctx.fillRect(x, baseY - height, barWidth, height);

                // Draw Label (Concentration)
                ctx.fillStyle = TEXT_COLOR;
                ctx.font = '14px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(labels[index], x + barWidth / 2, baseY + 20);

                // Draw Value (Efficiency %)
                ctx.font = 'bold 20px Inter';
                ctx.fillStyle = TEXT_COLOR;
                ctx.fillText(`${item.efficiency}%`, x + barWidth / 2, baseY - height - 10);
            });
        }
        
        // --- Experiment Control ---

        function restartExperiment() {
            // Stop any running animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Reset visual states
            bubbles = [];
            contaminantHeight = 50;
            progressBar.style.width = '0%';
            stabilityGauge.style.width = '0%';
            velocityGauge.style.width = '0%';
            stabilityValue.textContent = '0%';
            velocityValue.textContent = '0 m/s';
            simulationRunning = false;
            
            // Show Setup Screen
            setupDiv.classList.remove('hidden');
            runningDiv.classList.add('hidden');
            resultsDiv.classList.add('hidden');
            drawSetupScreen();
        }


        function startExperiment() {
            // Get selected concentration for potential data use (though data is fixed for demo)
            const selectedConcentration = concentrationSelect.value;
            console.log(`Starting experiment with ${selectedConcentration}M NaCl`);

            // Hide setup, show running
            setupDiv.classList.add('hidden');
            resultsDiv.classList.add('hidden');
            runningDiv.classList.remove('hidden');

            simulationRunning = true;
            contaminantHeight = 50; // Reset visual contaminant layer
            bubbles = [];
            let phaseIndex = 0;
            const totalDuration = 12000; // 12 seconds
            const phaseInterval = totalDuration / experimentPhases.length; // 4000ms per phase

            // Initial drawing of running screen
            animateRunning(0, 0);

            // Timer for phase progression
            const phaseTimer = setInterval(() => {
                if (phaseIndex < experimentPhases.length) {
                    // Update the text status
                    phaseStatus.innerHTML = experimentPhases[phaseIndex];
                    
                    // Update progress bar
                    progressBar.style.width = `${((phaseIndex + 1) / experimentPhases.length) * 100}%`;
                    
                    // Update Live Metrics based on the phase just completed
                    if (phaseIndex === 0) { // CFD Stability Phase Complete
                        stabilityGauge.style.width = '95%';
                        stabilityValue.textContent = '95%';
                    } else if (phaseIndex === 1) { // MD Cavitation Phase Complete
                        velocityGauge.style.width = '75%';
                        velocityValue.textContent = '90 m/s';
                    }

                    phaseIndex++;
                } else {
                    clearInterval(phaseTimer);
                }
            }, phaseInterval);

            // After total duration, show results
            setTimeout(() => {
                simulationRunning = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                
                runningDiv.classList.add('hidden');
                resultsDiv.classList.remove('hidden');
                drawResultsScreen();
            }, totalDuration);
        }

        function animateRunning() {
            if (!simulationRunning) return;

            // Calculate current metrics based on the progress bar width
            const currentProgress = parseFloat(progressBar.style.width.replace('%', ''));
            
            let currentStability = 0;
            let currentVelocity = 0;

            const P1_END = 33.3;
            const P2_END = 66.6;

            if (currentProgress > 0) {
                if (currentProgress <= P1_END) {
                    // Phase 1 (CFD - Stability)
                    currentStability = (currentProgress / P1_END) * 30; // Ramp up stability to 30%
                } else if (currentProgress <= P2_END) {
                    // Phase 2 (MD - Cavitation)
                    currentStability = 30 + ((currentProgress - P1_END) / (P2_END - P1_END)) * 65; // Stability jumps to 95%
                    currentVelocity = ((currentProgress - P1_END) / (P2_END - P1_END)) * 90; // Velocity ramps up to 90 m/s
                } else {
                    // Phase 3 (Results Calculation)
                    currentStability = 95;
                    currentVelocity = 90;
                }
            }
            
            // Draw the visual experiment
            drawRunningScreen();
            
            // Overlay the live metrics
            drawMetrics(Math.min(95, Math.round(currentStability)), Math.min(90, Math.round(currentVelocity)));

            // Loop animation
            animationFrameId = requestAnimationFrame(animateRunning);
        }

        // --- Initial Load ---
        window.onload = function() {
            restartExperiment(); // Initial setup draw
        }

    </script>
</body>
</html>
