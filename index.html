<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nanobubble Cleaning Digital Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #1a1a2e;
            --accent-color: #00bcd4;
            --success-color: #4CAF50;
            --warning-color: #FFC107;
            --text-color: #e4e4e7;
            --subtle-text: #a1a1aa;
            --contaminant-color: #5d4037;
            --nanobubble-color: rgba(128, 216, 255, 0.8);
            --glass-color: rgba(150, 200, 255, 0.15);
            --glass-border: rgba(150, 200, 255, 0.6); 
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 100%;
            height: 100%;
            max-width: 950px;
            background-color: #24243e;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            box-sizing: border-box;
        }

        /* Header Area - Fixed Height */
        .header-area {
            flex: 0 0 auto;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        /* Main Content - Flexible */
        .content-area {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 0; /* Crucial for nested flex scrolling */
            width: 100%;
            position: relative;
        }

        .card {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 0.5rem;
            background-color: #2d2d4d;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }

        /* Canvas wrapper takes available space */
        .canvas-wrapper {
            flex: 1 1 auto;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        canvas {
            background-color: #1a1a2e;
            border-radius: 0.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.7);
            /* Max dimensions to ensure it doesn't overflow */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Controls Area - Fixed Height at bottom */
        .controls-area {
            flex: 0 0 auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: var(--primary-color);
            padding: 10px 20px;
            border-radius: 0.5rem;
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            cursor: pointer;
            width: 100%;
            max-width: 280px;
            font-size: 0.9rem;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 188, 212, 0.4);
        }

        select {
            font-size: 0.9rem;
            padding: 0.4rem;
        }

        .metric-box {
            font-size: 0.8rem;
        }

        .progress-bar-container {
            height: 8px;
            background-color: #3f3f5a;
            border-radius: 4px;
            overflow: hidden;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--success-color);
            transition: width 0.5s ease-out;
        }

        .metric-gauge {
            width: 100%;
            height: 6px;
            background-color: #3f3f5a;
            border-radius: 3px;
            overflow: hidden;
        }

        .metric-fill {
            height: 100%;
            width: 0%;
            background-color: var(--warning-color);
            transition: width 0.5s ease-out;
        }
        
        @media (min-width: 768px) {
            .container { border-radius: 1rem; padding: 1.5rem; height: 95vh; }
            .card { padding: 1rem; }
            .btn-primary { padding: 12px 24px; font-size: 1rem; }
            h1 { font-size: 2.25rem; }
        }
    </style>
</head>
<body class="selection:bg-cyan-500 selection:text-white">

    <div class="container">
        <div class="header-area">
            <h1 class="text-xl md:text-3xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-teal-500 leading-tight">
                Nanobubble Cleaning Lab
            </h1>
            <p class="text-xs text-subtle-text mt-1 truncate">Project: Electrolyte-Enhanced Cavitation</p>
        </div>

        <div class="content-area">
            <div class="card">
                <!-- Canvas auto-resizes in this wrapper -->
                <div class="canvas-wrapper" id="canvasContainer">
                    <canvas id="experimentCanvas"></canvas>
                </div>

                <!-- Controls Section -->
                <div class="controls-area">
                    
                    <!-- Setup Controls -->
                    <div id="setupDiv" class="w-full max-w-md flex flex-col items-center gap-2">
                        <div class="w-full bg-gray-700/30 rounded p-2 text-left">
                            <label for="concentration" class="block text-xs font-medium text-accent-color mb-1">Electrolyte Concentration:</label>
                            <select id="concentration" class="w-full bg-gray-700 text-text-color border border-gray-600 rounded focus:ring-cyan-500 focus:border-cyan-500 cursor-pointer">
                                <option value="0.0">Pure Water (Control: 0.0M)</option>
                                <option value="0.005">Low Salt (0.005M NaCl)</option>
                                <option value="0.01" selected>Optimized Salt (0.01M NaCl)</option>
                                <option value="0.02">High Salt (0.02M NaCl)</option>
                            </select>
                            <p class="text-[10px] text-gray-400 mt-1 italic truncate" id="concentrationDesc">*Current: Optimum conditions hypothesized.</p>
                        </div>
                        <button id="startButton" class="btn-primary" onclick="startExperiment()">Run Simulation</button>
                    </div>

                    <!-- Running Controls -->
                    <div id="runningDiv" class="hidden w-full flex flex-col items-center">
                        <div class="w-full flex justify-between items-end mb-1 px-1">
                            <span class="text-xs font-bold text-accent-color">RUNNING...</span>
                            <span id="phaseStatus" class="text-[10px] font-mono text-success-color text-right truncate w-2/3">Phase 1...</span>
                        </div>
                        <div class="progress-bar-container">
                            <div id="progressBar" class="progress-bar"></div>
                        </div>
                        
                        <div class="flex w-full gap-2 mt-1">
                            <div class="flex-1 bg-gray-700/30 rounded p-2 metric-box">
                                <div class="flex justify-between mb-1">
                                    <span class="text-subtle-text">Stability</span>
                                    <span id="stabilityValue" class="text-warning-color font-mono">0%</span>
                                </div>
                                <div class="metric-gauge"><div id="stabilityGauge" class="metric-fill"></div></div>
                            </div>
                            <div class="flex-1 bg-gray-700/30 rounded p-2 metric-box">
                                <div class="flex justify-between mb-1">
                                    <span class="text-subtle-text">Velocity</span>
                                    <span id="velocityValue" class="text-warning-color font-mono">0 m/s</span>
                                </div>
                                <div class="metric-gauge"><div id="velocityGauge" class="metric-fill"></div></div>
                            </div>
                        </div>
                    </div>

                    <!-- Results Controls -->
                    <div id="resultsDiv" class="hidden w-full flex flex-col items-center gap-2">
                        <h2 class="text-lg font-bold text-success-color" id="finalTitle">FINAL RESULTS</h2>
                        <button class="btn-primary" onclick="restartExperiment()">New Experiment</button>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas and DOM Setup ---
        const canvas = document.getElementById('experimentCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        
        // Logical resolution 
        const LOGICAL_WIDTH = 800;
        const LOGICAL_HEIGHT = 450;
        let scaleFactor = 1;

        const setupDiv = document.getElementById('setupDiv');
        const runningDiv = document.getElementById('runningDiv');
        const resultsDiv = document.getElementById('resultsDiv');
        const phaseStatus = document.getElementById('phaseStatus');
        const progressBar = document.getElementById('progressBar');
        const concentrationSelect = document.getElementById('concentration');
        const concentrationDesc = document.getElementById('concentrationDesc');
        const finalTitle = document.getElementById('finalTitle');

        const stabilityGauge = document.getElementById('stabilityGauge');
        const stabilityValue = document.getElementById('stabilityValue');
        const velocityGauge = document.getElementById('velocityGauge');
        const velocityValue = document.getElementById('velocityValue');

        // --- Constants ---
        const ACCENT_COLOR = '#00bcd4';
        const PRIMARY_COLOR = '#1a1a2e';
        const CONTAMINANT_COLOR = '#5d4037';
        const NANOBUBBLE_COLOR = 'rgba(128, 216, 255, 0.8)';
        const WARNING_COLOR = '#FFC107';
        const TEXT_COLOR = '#e4e4e7';
        const BEAKER_COLOR = 'rgba(150, 200, 255, 0.15)'; 
        const BEAKER_STROKE = 'rgba(150, 200, 255, 0.6)'; 

        // --- Enhanced Responsive Canvas Logic ---
        function resizeCanvas() {
            if (!canvasContainer) return;

            // Available space in the wrapper
            const availableWidth = canvasContainer.clientWidth;
            const availableHeight = canvasContainer.clientHeight;

            // Desired Aspect Ratio
            const aspectRatio = LOGICAL_WIDTH / LOGICAL_HEIGHT;

            // Calculate scaling to fit CONTAIN within available space
            let displayWidth, displayHeight;

            if (availableWidth / availableHeight < aspectRatio) {
                // Width limited
                displayWidth = availableWidth;
                displayHeight = availableWidth / aspectRatio;
            } else {
                // Height limited
                displayHeight = availableHeight;
                displayWidth = availableHeight * aspectRatio;
            }

            // Set canvas size
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            
            // Calculate scale factor relative to logical size
            scaleFactor = displayWidth / LOGICAL_WIDTH;
            
            // Force redraw
            if (!simulationRunning && !resultsAnimating && !currentScenario) {
                drawSetupScreen();
            } else if (currentScenario && !simulationRunning && !resultsAnimating) {
                if(currentScenario) drawSingleResultCard();
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // --- Simulation Configuration Data ---
        const scenarioData = {
            '0.0': { 
                name: 'Pure Water (Control)',
                stability: 35, velocity: 40, bubbleRate: 0.1, bubbleLife: 0.3, efficiency: 35, color: '#e57373',
                desc: "Pure water lacks ions to stabilize the bubble surface.",
                analysis: ["Analysis: FAILED. Weak repulsive forces.", "Result: Minimal cleaning."]
            },
            '0.005': { 
                name: 'Low Salt (0.005M)',
                stability: 65, velocity: 70, bubbleRate: 0.5, bubbleLife: 0.7, efficiency: 68, color: '#ffee58',
                desc: "Small electrolyte amount improves stability.",
                analysis: ["Analysis: MODERATE. Reduced coalescence.", "Result: Partial cleaning."]
            },
            '0.01': { 
                name: 'Optimized Salt (0.01M)',
                stability: 95, velocity: 110, bubbleRate: 1.0, bubbleLife: 1.0, efficiency: 92, color: '#66bb6a',
                desc: "Optimal ionic strength maximizes cavitation.",
                analysis: ["Analysis: SUCCESS. Optimized Zeta Potential.", "Result: Max efficiency."]
            },
            '0.02': { 
                name: 'High Salt (0.02M)',
                stability: 50, velocity: 55, bubbleRate: 0.4, bubbleLife: 0.6, efficiency: 45, color: '#ff8a65',
                desc: "Excessive salt increases surface tension.",
                analysis: ["Analysis: SUB-OPTIMAL. Shielding effect.", "Result: Reduced cleaning."]
            }
        };

        const experimentPhases = [
            'Stability Analysis...', 'Modeling Jets...', 'Calculating Eff...'
        ];

        let bubbles = [];
        let contaminantHeight = 50;
        let animationFrameId = null;
        let simulationRunning = false;
        let resultsAnimating = false;
        let resultAnimationProgress = 0; 
        let currentScenario = null;
        
        // Logical Dimensions for Griffin Beaker
        const beaker = {
            width: 280, height: 320, radius: 15, x: 0, y: 0, wallThickness: 8
        };

        concentrationSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if(scenarioData[val]) concentrationDesc.textContent = scenarioData[val].desc;
        });

        // --- Drawing Helpers ---
        function clearAndScale() {
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = PRIMARY_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.scale(scaleFactor, scaleFactor);
        }

        function drawBeaker(x, y, isOutline = true) {
            ctx.lineWidth = isOutline ? 3 : 1;
            ctx.strokeStyle = isOutline ? BEAKER_STROKE : 'rgba(255,255,255,0.1)';
            ctx.fillStyle = BEAKER_COLOR;

            const halfWidth = beaker.width / 2;
            const top = y;
            const bottom = y + beaker.height;
            const cornerRadius = beaker.radius;

            ctx.beginPath();
            ctx.moveTo(x - halfWidth, top);
            ctx.lineTo(x - halfWidth, bottom - cornerRadius);
            ctx.quadraticCurveTo(x - halfWidth, bottom, x - halfWidth + cornerRadius, bottom);
            ctx.lineTo(x + halfWidth - cornerRadius, bottom);
            ctx.quadraticCurveTo(x + halfWidth, bottom, x + halfWidth, bottom - cornerRadius);
            ctx.lineTo(x + halfWidth, top);
            ctx.lineTo(x + halfWidth + 10, top - 5); 
            ctx.lineTo(x + halfWidth, top); 
            
            if (isOutline) {
               ctx.stroke();
               ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
               ctx.font = '10px Inter';
               ctx.textAlign = 'right';
               const step = beaker.height / 6;
               for(let i=1; i<=5; i++) {
                   const tickY = bottom - (step * i);
                   ctx.beginPath();
                   ctx.moveTo(x - halfWidth, tickY);
                   ctx.lineTo(x - halfWidth + 15, tickY);
                   ctx.stroke();
                   ctx.fillText((i * 100) + 'ml', x - halfWidth - 5, tickY + 3);
               }
            } else {
                ctx.fill();
            }
            ctx.closePath();
            return new Path2D(ctx.currentPath);
        }
        
        function drawSetupScreen() {
            clearAndScale();

            const midX = LOGICAL_WIDTH / 2;
            const midY = LOGICAL_HEIGHT / 2;
            const topY = 40;
            beaker.x = midX;
            beaker.y = topY;

            drawBeaker(midX, topY, true);

            ctx.save();
            const innerHalfWidth = beaker.width / 2 - 4;
            const innerX = midX;
            const innerTop = topY + 10; 
            const innerBottom = topY + beaker.height - 4;

            ctx.beginPath();
            ctx.rect(innerX - innerHalfWidth, innerTop, innerHalfWidth * 2, innerBottom - innerTop);
            ctx.clip();

            const waterGradient = ctx.createLinearGradient(0, topY + beaker.height, 0, topY);
            waterGradient.addColorStop(0, 'rgba(0, 188, 212, 0.4)');
            waterGradient.addColorStop(1, 'rgba(0, 188, 212, 0.1)');
            ctx.fillStyle = waterGradient;
            ctx.fillRect(innerX - innerHalfWidth, innerTop, beaker.width, beaker.height);
            
            ctx.fillStyle = CONTAMINANT_COLOR;
            ctx.fillRect(innerX - innerHalfWidth, innerBottom - contaminantHeight, beaker.width, contaminantHeight);
            ctx.restore();
            
            // Base
            ctx.fillStyle = '#37474f'; 
            ctx.beginPath();
            ctx.moveTo(midX - 160, topY + beaker.height + 5);
            ctx.lineTo(midX + 160, topY + beaker.height + 5);
            ctx.lineTo(midX + 170, topY + beaker.height + 35);
            ctx.lineTo(midX - 170, topY + beaker.height + 35);
            ctx.fill();
            
            ctx.fillStyle = '#263238';
            ctx.fillRect(midX - 170, topY + beaker.height + 35, 340, 15);
            
            ctx.fillStyle = '#90a4ae';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText("NANOGENERATOR", midX, topY + beaker.height + 46);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px Inter';
            ctx.fillText('Aqueous Phase', midX, midY - 10);

            ctx.fillStyle = 'rgba(255, 180, 180, 0.9)';
            ctx.fillText('Biofilm Layer', midX, topY + beaker.height - 25);
            
            ctx.fillStyle = ACCENT_COLOR;
            ctx.font = 'bold 14px Inter';
            ctx.fillText('STATUS: STANDBY', midX, topY - 20);
        }

        function createBubble(size = 3) {
            const spawnWidth = beaker.width - 40; 
            return {
                x: beaker.x - (spawnWidth / 2) + Math.random() * spawnWidth,
                y: beaker.y + beaker.height - 15, 
                radius: size + Math.random() * 2,
                speed: 0.5 + Math.random() * 1.5, 
                opacity: 0.1, 
                maxOpacity: 0.6 + Math.random() * 0.4,
                bursting: false,
                burstTimer: 0
            };
        }

        function updateBubbles() {
            const liquidBottomY = beaker.y + beaker.height - 4;
            const cleaningSurfaceY = liquidBottomY - contaminantHeight;
            const innerTopY = beaker.y + 10;
            
            const cleaningPower = (currentScenario.velocity / 100) * (currentScenario.stability / 100);
            const baseRate = 0.15; 

            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.y -= b.speed;
                
                if (b.opacity < b.maxOpacity) b.opacity += 0.05;

                if (!b.bursting && Math.random() > currentScenario.bubbleLife + 0.02) {
                     b.bursting = true;
                     b.burstTimer = 5; 
                }

                if (b.y <= cleaningSurfaceY && b.y > cleaningSurfaceY - 10 && !b.bursting) {
                    b.bursting = true;
                    b.burstTimer = 8; 
                    contaminantHeight = Math.max(5, contaminantHeight - (baseRate * cleaningPower)); 
                }

                if (b.bursting) {
                    b.burstTimer--;
                    if (b.burstTimer <= 0) bubbles.splice(i, 1);
                } else if (b.y < innerTopY) {
                    bubbles.splice(i, 1);
                }
            }
        }

        function drawBubbles() {
            for (const b of bubbles) {
                if (b.bursting) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${b.burstTimer / 8})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = `rgba(128, 216, 255, ${b.opacity})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawRunningScreen() {
            clearAndScale();

            const midX = LOGICAL_WIDTH / 2;
            const topY = 40;
            beaker.x = midX;
            beaker.y = topY;

            drawBeaker(midX, topY, true);

            ctx.save();
            const innerHalfWidth = beaker.width / 2 - 4;
            const innerX = midX;
            const innerTop = topY + 10;
            const innerBottom = topY + beaker.height - 4;

            ctx.beginPath();
            ctx.rect(innerX - innerHalfWidth, innerTop, innerHalfWidth * 2, innerBottom - innerTop);
            ctx.clip(); 

            const waterGradient = ctx.createLinearGradient(0, topY + beaker.height, 0, topY);
            waterGradient.addColorStop(0, 'rgba(0, 188, 212, 0.4)');
            waterGradient.addColorStop(1, 'rgba(0, 188, 212, 0.1)');
            ctx.fillStyle = waterGradient;
            ctx.fillRect(innerX - innerHalfWidth, innerTop, beaker.width, beaker.height);

            ctx.fillStyle = CONTAMINANT_COLOR;
            ctx.fillRect(innerX - innerHalfWidth, innerBottom - contaminantHeight, beaker.width, contaminantHeight);
            
            updateBubbles();
            drawBubbles();
            
            ctx.restore(); 
            
             ctx.fillStyle = '#37474f';
            ctx.beginPath();
            ctx.moveTo(midX - 160, topY + beaker.height + 5);
            ctx.lineTo(midX + 160, topY + beaker.height + 5);
            ctx.lineTo(midX + 170, topY + beaker.height + 35);
            ctx.lineTo(midX - 170, topY + beaker.height + 35);
            ctx.fill();
            ctx.fillStyle = '#263238';
            ctx.fillRect(midX - 170, topY + beaker.height + 35, 340, 15);
             ctx.fillStyle = '#90a4ae';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText("NANOGENERATOR", midX, topY + beaker.height + 46);

            if (currentScenario && Math.random() < currentScenario.bubbleRate) { 
                let spawnCount = 1;
                if(currentScenario.bubbleRate >= 0.9) spawnCount = 4;
                else if(currentScenario.bubbleRate >= 0.5) spawnCount = 2;

                for(let k=0; k<spawnCount; k++) {
                    bubbles.push(createBubble());
                }
            }
        }

        function drawSingleResultCard() {
            clearAndScale();

            const cx = LOGICAL_WIDTH / 2;
            const cy = LOGICAL_HEIGHT / 2;

            const radius = 90;
            const startAngle = -Math.PI;
            const endAngle = 0;
            
            ctx.lineWidth = 20;
            ctx.strokeStyle = '#3f3f5a';
            ctx.beginPath();
            ctx.arc(cx, cy - 50, radius, startAngle, endAngle);
            ctx.stroke();

            const animatedEff = currentScenario.efficiency * resultAnimationProgress;
            const progressAngle = startAngle + (animatedEff / 100) * (endAngle - startAngle);
            
            ctx.strokeStyle = currentScenario.color;
            ctx.beginPath();
            ctx.arc(cx, cy - 50, radius, startAngle, progressAngle);
            ctx.stroke();

            ctx.textAlign = 'center';
            ctx.fillStyle = TEXT_COLOR;
            ctx.font = 'bold 40px Inter';
            ctx.fillText(`${Math.round(animatedEff)}%`, cx, cy - 60);
            ctx.font = '14px Inter';
            ctx.fillStyle = '#a1a1aa';
            ctx.fillText('CLEANING EFFICIENCY', cx, cy - 30);


            if (resultAnimationProgress > 0.8) {
                const boxY = cy + 20;
                const boxHeight = 140;
                const boxWidth = 600;
                const safeBoxWidth = Math.min(boxWidth, LOGICAL_WIDTH - 40);

                ctx.fillStyle = 'rgba(45, 45, 77, 0.5)';
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.fillRect(cx - safeBoxWidth/2, boxY, safeBoxWidth, boxHeight);
                ctx.strokeRect(cx - safeBoxWidth/2, boxY, safeBoxWidth, boxHeight);

                ctx.textAlign = 'left';
                ctx.fillStyle = currentScenario.color;
                ctx.font = 'bold 18px Inter';
                ctx.fillText(currentScenario.name, cx - safeBoxWidth/2 + 20, boxY + 30);

                ctx.fillStyle = TEXT_COLOR;
                ctx.font = '16px Inter';
                let lineY = boxY + 60;
                currentScenario.analysis.forEach(line => {
                    ctx.fillText(line, cx - safeBoxWidth/2 + 20, lineY);
                    lineY += 22;
                });
            }

            if (resultsAnimating) {
                resultAnimationProgress += 0.02;
                if (resultAnimationProgress >= 1) {
                    resultAnimationProgress = 1;
                    resultsAnimating = false; 
                }
                animationFrameId = requestAnimationFrame(drawSingleResultCard);
            }
        }
        
        function restartExperiment() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            bubbles = [];
            contaminantHeight = 50;
            progressBar.style.width = '0%';
            stabilityGauge.style.width = '0%';
            velocityGauge.style.width = '0%';
            stabilityValue.textContent = '0%';
            velocityValue.textContent = '0 m/s';
            simulationRunning = false;
            resultsAnimating = false;
            resultAnimationProgress = 0;
            currentScenario = null;
            
            setupDiv.classList.remove('hidden');
            runningDiv.classList.add('hidden');
            resultsDiv.classList.add('hidden');
            
            resizeCanvas();
            drawSetupScreen();
        }

        function startExperiment() {
            const selectedValue = concentrationSelect.value;
            currentScenario = scenarioData[selectedValue]; 
            
            setupDiv.classList.add('hidden');
            resultsDiv.classList.add('hidden');
            runningDiv.classList.remove('hidden');

            simulationRunning = true;
            contaminantHeight = 50; 
            bubbles = [];
            let phaseIndex = 0;
            const totalDuration = 10000; 
            const phaseInterval = totalDuration / experimentPhases.length; 

            animateRunning();

            const phaseTimer = setInterval(() => {
                if (phaseIndex < experimentPhases.length) {
                    phaseStatus.innerHTML = experimentPhases[phaseIndex];
                    progressBar.style.width = `${((phaseIndex + 1) / experimentPhases.length) * 100}%`;
                    phaseIndex++;
                } else {
                    clearInterval(phaseTimer);
                }
            }, phaseInterval);

            setTimeout(() => {
                simulationRunning = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                
                runningDiv.classList.add('hidden');
                resultsDiv.classList.remove('hidden');
                
                if (currentScenario.efficiency > 85) {
                    finalTitle.innerHTML = "ðŸŽ‰ OPTIMIZED!";
                    finalTitle.className = "text-lg md:text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500";
                } else {
                    finalTitle.innerHTML = "EXPERIMENTAL RESULTS";
                    finalTitle.className = "text-lg md:text-2xl font-bold text-success-color";
                }

                resultsAnimating = true;
                resultAnimationProgress = 0;
                drawSingleResultCard(); 
            }, totalDuration);
        }

        function animateRunning() {
            if (!simulationRunning || !currentScenario) return;

            const currentProgress = parseFloat(progressBar.style.width.replace('%', '')) || 0;
            
            let currentStability = 0;
            let currentVelocity = 0;

            const targetStability = currentScenario.stability;
            const targetVelocity = currentScenario.velocity;

            const P1_END = 33.3;
            const P2_END = 66.6;

            if (currentProgress > 0) {
                if (currentProgress <= P1_END) {
                    currentStability = (currentProgress / P1_END) * (targetStability * 0.3); 
                } else if (currentProgress <= P2_END) {
                    const phaseProgress = (currentProgress - P1_END) / (P2_END - P1_END);
                    const startStability = targetStability * 0.3;
                    currentStability = startStability + (phaseProgress * (targetStability - startStability));
                    currentVelocity = phaseProgress * targetVelocity;
                } else {
                    currentStability = targetStability;
                    currentVelocity = targetVelocity;
                }
            }
            
            drawRunningScreen();
            
            stabilityGauge.style.width = `${Math.min(100, currentStability)}%`;
            stabilityValue.textContent = `${currentStability.toFixed(0)}%`;
            
            velocityGauge.style.width = `${Math.min(100, (currentVelocity/150)*100)}%`;
            velocityValue.textContent = `${currentVelocity.toFixed(0)} m/s`;

            animationFrameId = requestAnimationFrame(animateRunning);
        }

        window.onload = function() {
            const event = new Event('change');
            concentrationSelect.dispatchEvent(event);
            
            resizeCanvas();
            restartExperiment(); 
        }
    </script>
</body>
</html>
